<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HeiBaoBox源码分析(2)----启动APK | 清风醉博客</title><meta name="keywords" content="HeiBaoBox"><meta name="author" content="清风醉博客"><meta name="copyright" content="清风醉博客"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一.创建应用进程Android应用进程的启动是被动式的，在桌面点击图标启动一个应用的组件如Activity时，如果Activity所在的进程不存在，就会创建并启动进程。**Android系统中一般应用进程的创建都是统一由zygote进程fork创建的，AMS在需要创建应用进程时，会通过socket连接并通知到到zygote进程在开机阶段就创建好的socket服务端，然后由zygote进程fork创">
<meta property="og:type" content="article">
<meta property="og:title" content="HeiBaoBox源码分析(2)----启动APK">
<meta property="og:url" content="http://ljm2007.github.io/2023/09/07/HeiBaoBox%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(2)----%E5%90%AF%E5%8A%A8APK/index.html">
<meta property="og:site_name" content="清风醉博客">
<meta property="og:description" content="一.创建应用进程Android应用进程的启动是被动式的，在桌面点击图标启动一个应用的组件如Activity时，如果Activity所在的进程不存在，就会创建并启动进程。**Android系统中一般应用进程的创建都是统一由zygote进程fork创建的，AMS在需要创建应用进程时，会通过socket连接并通知到到zygote进程在开机阶段就创建好的socket服务端，然后由zygote进程fork创">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/09/07/Q3kjRwDr8dlMZbC.webp">
<meta property="article:published_time" content="2023-09-07T02:33:23.000Z">
<meta property="article:modified_time" content="2024-02-09T04:06:41.616Z">
<meta property="article:author" content="清风醉博客">
<meta property="article:tag" content="HeiBaoBox">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/09/07/Q3kjRwDr8dlMZbC.webp"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://ljm2007.github.io/2023/09/07/HeiBaoBox%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(2)----%E5%90%AF%E5%8A%A8APK/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HeiBaoBox源码分析(2)----启动APK',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-09 12:06:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/list/"><i class="fa-fw fas fa-list"></i><span> 列表</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/09/07/Q3kjRwDr8dlMZbC.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">清风醉博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/list/"><i class="fa-fw fas fa-list"></i><span> 列表</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HeiBaoBox源码分析(2)----启动APK</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-07T02:33:23.000Z" title="发表于 2023-09-07 10:33:23">2023-09-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-09T04:06:41.616Z" title="更新于 2024-02-09 12:06:41">2024-02-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/HeiBaoBox/">HeiBaoBox</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HeiBaoBox源码分析(2)----启动APK"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一-创建应用进程"><a href="#一-创建应用进程" class="headerlink" title="一.创建应用进程"></a>一.创建应用进程</h2><p><code>Android</code>应用进程的启动是<strong>被动式</strong>的，在桌面点击图标启动一个应用的组件如<code>Activity</code>时，如果<code>Activity</code>所在的进程不存在，就会创建并启动进程。**<code>Android</code>系统中一般应用进程的创建都是统一由<code>zygote</code>进程<code>fork</code>创建的，<code>AMS</code>在需要创建应用进程时，会通过<code>socket</code>连接并通知到到<code>zygote</code>进程在开机阶段就创建好的<code>socket</code>服务端，然后由<code>zygote</code>进程<code>fork</code>创建出应用进程。**整体架构如下图所示：</p>
<img src="https://s2.loli.net/2023/09/07/Q3kjRwDr8dlMZbC.webp" alt="img" style="zoom: 50%;">

<p>从<code>AMS#startProcessAsync</code>创建进程函数入手，继续看一下应用进程创建相关简化流程代码：</p>
<h3 id="1-AMS-发送socket请求"><a href="#1-AMS-发送socket请求" class="headerlink" title="1.AMS 发送socket请求"></a>1.AMS 发送socket请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java*/</span>  </span><br><span class="line">   <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">final</span> ProcessRecord <span class="title function_">startProcessLocked</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mProcessList.startProcessLocked(...);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*frameworks/base/services/core/java/com/android/server/am/ProcessList.java*/</span></span><br><span class="line">   <span class="keyword">private</span> Process.ProcessStartResult <span class="title function_">startProcess</span><span class="params">(HostingRecord hostingRecord, String entryPoint,</span></span><br><span class="line"><span class="params">            ProcessRecord app, <span class="type">int</span> uid, <span class="type">int</span>[] gids, <span class="type">int</span> runtimeFlags, <span class="type">int</span> zygotePolicyFlags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> mountExternal, String seInfo, String requiredAbi, String instructionSet,</span></span><br><span class="line"><span class="params">            String invokeWith, <span class="type">long</span> startTime)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 原生标识应用进程创建所加的systrace tag</span></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;Start proc: &quot;</span> +</span><br><span class="line">                    app.processName);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 调用Process的start方法创建进程</span></span><br><span class="line">            startResult = Process.start(...);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*frameworks/base/core/java/android/os/Process.java*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ProcessStartResult <span class="title function_">start</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用ZygoteProcess的start函数</span></span><br><span class="line">        <span class="keyword">return</span> ZYGOTE_PROCESS.start(...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*frameworks/base/core/java/android/os/ZygoteProcess.java*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Process.ProcessStartResult <span class="title function_">start</span><span class="params">(...)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startViaZygote(...);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Process.ProcessStartResult <span class="title function_">startViaZygote</span><span class="params">(...)</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ZygoteProcess#startViaZygote</code>中，最后创建应用进程的逻辑：</p>
<ol>
<li><strong><code>openZygoteSocketIfNeeded</code>函数中打开本地<code>socket</code>客户端连接到<code>zygote</code>进程的<code>socket</code>服务端</strong>；</li>
<li><strong><code>zygoteSendArgsAndGetResult</code>发送<code>socket</code>请求参数，带上了创建的应用进程参数信息</strong>；</li>
<li><strong><code>return</code>返回的数据结构<code>ProcessStartResult</code>中会有新创建的进程的<code>pid</code>字段</strong>。</li>
</ol>
<h3 id="2-Zygote-处理socket请求"><a href="#2-Zygote-处理socket请求" class="headerlink" title="2 Zygote 处理socket请求"></a>2 Zygote 处理socket请求</h3><p>其实早在系统开机阶段，<code>zygote</code>进程创建时，就会在<code>ZygoteInit#main</code>入口函数中创建服务端<code>socket</code>，<strong>并预加载系统资源和框架类（加速应用进程启动速度）</strong>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="type">ZygoteServer</span> <span class="variable">zygoteServer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">         ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 1.preload提前加载框架通用类和系统资源到进程，加速进程启动</span></span><br><span class="line">            preload(bootTimingsTraceLog);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 2.创建zygote进程的socket server服务端对象</span></span><br><span class="line">            zygoteServer = <span class="keyword">new</span> <span class="title class_">ZygoteServer</span>(isPrimaryZygote);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 3.进入死循环，等待AMS发请求过来</span></span><br><span class="line">            caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续往下看<code>ZygoteServer#runSelectLoop</code>如何监听并处理AMS客户端的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/com/android/internal/os/ZygoteServer.java*/</span></span><br><span class="line"> Runnable <span class="title function_">runSelectLoop</span><span class="params">(String abiList)</span> &#123;</span><br><span class="line">     <span class="comment">// 进入死循环监听</span></span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (--pollIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (pollIndex == <span class="number">0</span>) &#123;</span><br><span class="line">             ...</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;</span><br><span class="line">             <span class="comment">// Session socket accepted from the Zygote server socket</span></span><br><span class="line">             <span class="comment">// 得到一个请求连接封装对象ZygoteConnection</span></span><br><span class="line">             <span class="type">ZygoteConnection</span> <span class="variable">connection</span> <span class="operator">=</span> peers.get(pollIndex);</span><br><span class="line">             <span class="comment">// processCommand函数中处理AMS客户端请求</span></span><br><span class="line">             <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> connection.processCommand(<span class="built_in">this</span>, multipleForksOK);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Runnable <span class="title function_">processCommand</span><span class="params">(ZygoteServer zygoteServer, <span class="type">boolean</span> multipleOK)</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 1.fork创建应用子进程</span></span><br><span class="line">         pid = Zygote.forkAndSpecialize(...);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                 ...</span><br><span class="line">                 <span class="comment">// 2.pid为0，当前处于新创建的子应用进程中，处理请求参数</span></span><br><span class="line">                 <span class="keyword">return</span> handleChildProc(parsedArgs, childPipeFd, parsedArgs.mStartChildZygote);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 ...</span><br><span class="line">                 handleParentProc(pid, serverPipeFd);</span><br><span class="line">             &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             ...</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> Runnable <span class="title function_">handleChildProc</span><span class="params">(ZygoteArguments parsedArgs,</span></span><br><span class="line"><span class="params">            FileDescriptor pipeFd, <span class="type">boolean</span> isZygote)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 关闭从父进程zygote继承过来的ZygoteServer服务端地址</span></span><br><span class="line">        closeSocket();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.mInvokeWith != <span class="literal">null</span>) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isZygote) &#123;</span><br><span class="line">                <span class="comment">// 继续进入ZygoteInit#zygoteInit继续完成子应用进程的相关初始化工作</span></span><br><span class="line">                <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                        parsedArgs.mDisabledCompatChanges,</span><br><span class="line">                        parsedArgs.mRemainingArgs, <span class="literal">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上过程从systrace上看如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/07/yD2RmodZ3841Alk.webp" alt="img"></p>
<h3 id="3-应用进程初始化"><a href="#3-应用进程初始化" class="headerlink" title="3 应用进程初始化"></a>3 应用进程初始化</h3><p>接上一节中的分析，<code>zygote</code>进程监听接收<code>AMS</code>的请求，<code>fork</code>创建子应用进程，然后<code>pid</code>为0时进入子进程空间，然后在 <code>ZygoteInit#zygoteInit</code>中完成进程的初始化动作，相关简化代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title function_">zygoteInit</span><span class="params">(<span class="type">int</span> targetSdkVersion, <span class="type">long</span>[] disabledCompatChanges,</span></span><br><span class="line"><span class="params">            String[] argv, ClassLoader classLoader)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 原生添加名为“ZygoteInit ”的systrace tag以标识进程初始化流程</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ZygoteInit&quot;</span>);</span><br><span class="line">        RuntimeInit.redirectLogStreams();</span><br><span class="line">        <span class="comment">// 1.RuntimeInit#commonInit中设置应用进程默认的java异常处理机制</span></span><br><span class="line">        RuntimeInit.commonInit();</span><br><span class="line">        <span class="comment">// 2.ZygoteInit#nativeZygoteInit函数中JNI调用启动进程的binder线程池</span></span><br><span class="line">        ZygoteInit.nativeZygoteInit();</span><br><span class="line">        <span class="comment">// 3.RuntimeInit#applicationInit中反射创建ActivityThread对象并调用其“main”入口方法</span></span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">                classLoader);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>应用进程启动后，初始化过程中主要依次完成以下几件事情：</p>
<ol>
<li><strong>应用进程默认的<code>java</code>异常处理机制（可以实现监听、拦截应用进程所有的<code>Java crash</code>的逻辑）；</strong></li>
<li><strong><code>JNI</code>调用启动进程的<code>binder</code>线程池（注意应用进程的<code>binder</code>线程池资源是自己创建的并非从<code>zygote</code>父进程继承的）；</strong></li>
<li><strong>通过反射创建<code>ActivityThread</code>对象并调用其“<code>main</code>”入口方法。</strong></li>
</ol>
<p>我们继续看<code>RuntimeInit#applicationInit</code>简化的代码流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/com/android/internal/os/RuntimeInit.java*/</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title function_">applicationInit</span><span class="params">(<span class="type">int</span> targetSdkVersion, <span class="type">long</span>[] disabledCompatChanges,</span></span><br><span class="line"><span class="params">            String[] argv, ClassLoader classLoader)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 结束“ZygoteInit ”的systrace tag</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        <span class="comment">// Remaining arguments are passed to the start class&#x27;s static main</span></span><br><span class="line">        <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title function_">findStaticMain</span><span class="params">(String className, String[] argv,</span></span><br><span class="line"><span class="params">            ClassLoader classLoader)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.反射加载创建ActivityThread类对象</span></span><br><span class="line">            cl = Class.forName(className, <span class="literal">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        Method m;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.反射调用其main方法</span></span><br><span class="line">            m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String[].class &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 3.触发执行以上逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodAndArgsCaller</span>(m, argv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们继续往下看<code>ActivityThread</code>的<code>main</code>函数中又干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityThread.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">// 原生添加的标识进程ActivityThread初始化过程的systrace tag，名为“ActivityThreadMain”</span></span><br><span class="line">     Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 1.创建并启动主线程的loop消息循环</span></span><br><span class="line">     Looper.prepareMainLooper();</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 2.attachApplication注册到系统AMS中</span></span><br><span class="line">     <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">     thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line">     ...</span><br><span class="line">     Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">     Looper.loop();</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(<span class="type">boolean</span> system, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 通过binder调用AMS的attachApplication接口将自己注册到AMS中</span></span><br><span class="line">          mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到进程<code>ActivityThread#main</code>函数初始化的主要逻辑是：</p>
<ol>
<li><strong>创建并启动主线程的<code>loop</code>消息循环；</strong></li>
<li><strong>通过<code>binder</code>调用<code>AMS</code>的<code>attachApplication</code>接口将自己<code>attach</code>注册到<code>AMS</code>中。</strong></li>
</ol>
<p>以上初始化过程。从systrace上看如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/07/IxByElTXdM3g5J9.webp" alt="img"></p>
<h3 id="4-应用主线程消息循环机制建立"><a href="#4-应用主线程消息循环机制建立" class="headerlink" title="4. 应用主线程消息循环机制建立"></a>4. 应用主线程消息循环机制建立</h3><p>接上一节的分析，我们知道应用进程创建后会通过反射创建<code>ActivityThread</code>对象并执行其<code>main</code>函数，进行主线程的初始化工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityThread.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 1.创建Looper、MessageQueue</span></span><br><span class="line">     Looper.prepareMainLooper();</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 2.启动loop消息循环，开始准备接收消息</span></span><br><span class="line">     Looper.loop();</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建主线程Handler对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/os/Looper.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 准备主线程的Looper</span></span><br><span class="line">     prepare(<span class="literal">false</span>);</span><br><span class="line">     <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          sMainLooper = myLooper();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建主线程的Looper对象，并通过ThreadLocal机制实现与主线程的一对一绑定</span></span><br><span class="line">      sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">      <span class="comment">// 创建MessageQueue消息队列</span></span><br><span class="line">      mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">      mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程初始化完成后，<strong>主线程就有了完整的</strong> <strong><code>Looper</code>、<code>MessageQueue</code>、<code>Handler</code>，此时</strong> <strong><code>ActivityThread</code></strong> <strong>的</strong> <strong><code>Handler</code></strong> <strong>就可以开始处理</strong> <strong><code>Message</code>，包括</strong> <strong><code>Application</code>、<code>Activity</code>、<code>ContentProvider</code>、<code>Service</code>、<code>Broadcast</code></strong> <strong>等组件的生命周期函数，都会以</strong> <strong><code>Message</code></strong> <strong>的形式，在主线程按照顺序处理</strong>，这就是 <code>App</code> 主线程的初始化和运行原理，部分处理的 <code>Message</code> 如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityThread.java*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BIND_APPLICATION</span>        <span class="operator">=</span> <span class="number">110</span>;</span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RECEIVER</span>                <span class="operator">=</span> <span class="number">113</span>;</span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CREATE_SERVICE</span>          <span class="operator">=</span> <span class="number">114</span>;</span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BIND_SERVICE</span>            <span class="operator">=</span> <span class="number">121</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                    <span class="type">AppBindData</span> <span class="variable">data</span> <span class="operator">=</span> (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    ...</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程初始化完成后，主线程就进入阻塞状态，等待 <code>Message</code>，一旦有 <code>Message</code> 发过来，主线程就会被唤醒，处理 <code>Message</code>，处理完成之后，如果没有其他的 <code>Message</code> 需要处理，那么主线程就会进入休眠阻塞状态继续等待。可以说<code>Android</code>系统的运行是受消息机制驱动的，而整个消息机制是由上面所说的四个关键角色相互配合实现的（<code>**Handler**</code>、<code>**Looper**</code>、<code>**MessageQueue**</code>、<code>**Message**</code>），其运行原理如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/07/O1EZxNah2YyPG8b.webp" alt="img"></p>
<p>主要是用来处理 <code>Message</code>，应用可以在任何线程创建 <code>Handler</code>，只要在创建的时候指定对应的 <code>Looper</code> 即可，如果不指定，默认是在当前 <code>Thread</code> 对应的 <code>Looper</code>。</p>
<ol>
<li><strong><code>Looper</code>****:</strong><code>Looper</code> 可以看成是一个循环器，<strong>其</strong>**<code>loop</code><strong><strong>方法开启后，不断地从</strong></strong><code>MessageQueue</code><strong><strong>中获取</strong></strong><code>Message</code>**，对 <code>Message</code> 进行 <code>Delivery</code> 和 <code>Dispatch</code>，最终发给对应的 <code>Handler</code> 去处理。</li>
<li><code>**MessageQueue**：MessageQueue</code> 就是一个 <code>Message</code> 管理器，队列中是 <code>Message</code>，在没有 <code>Message</code> 的时候，<code>**MessageQueue**</code><strong>借助</strong><code>**Linux**</code><strong>的</strong><strong><code>ePoll</code>机制，阻塞休眠等待，直到有</strong><code>**Message**</code><strong>进入队列将其唤醒</strong>。</li>
<li><code>**Message**：Message</code> 是传递消息的对象，其内部包含了要传递的内容，最常用的包括 <code>what</code>、<code>arg</code>、<code>callback</code> 等。</li>
</ol>
<h2 id="二-应用Application和Activity组件创建与初始化"><a href="#二-应用Application和Activity组件创建与初始化" class="headerlink" title="二.应用Application和Activity组件创建与初始化"></a>二.应用Application和Activity组件创建与初始化</h2><h3 id="1-Application的创建与初始化"><a href="#1-Application的创建与初始化" class="headerlink" title="1 Application的创建与初始化"></a>1 Application的创建与初始化</h3><p>从前面结中的分析我们知道，<strong>应用进程启动初始化执行<code>ActivityThread#main</code>函数过程中，在开启主线程<code>loop</code>消息循环之前，会通过<code>Binder</code>调用系统核心服务<code>AMS</code>的<code>attachApplication</code>接口将自己注册到<code>AMS</code>中</strong>。下面我们接着这个流程往下看，我们先从systrace上看看<code>AMS</code>服务的<code>attachApplication</code>接口是如何处理应用进程的attach注册请求的：</p>
<p><img src="https://pic4.zhimg.com/80/v2-9fe5564a08917c9a5110ac46a4d98f03_1440w.webp" alt="img"></p>
<p>我们继续来看相关代码的简化流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java*/</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(<span class="meta">@NonNull</span> IApplicationThread thread,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> pid, <span class="type">int</span> callingUid, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span> (app.isolatedEntryPoint != <span class="literal">null</span>) &#123;</span><br><span class="line">           ...</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 1.通过oneway异步类型的binder调用应用进程ActivityThread#IApplicationThread#bindApplication接口</span></span><br><span class="line">           thread.bindApplication(...);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           thread.bindApplication(...);</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// See if the top visible activity is waiting to run in this process...</span></span><br><span class="line">     <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.继续执行启动应用Activity的流程</span></span><br><span class="line">            didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, <span class="string">&quot;Exception thrown launching activities in &quot;</span> + app, e);</span><br><span class="line">                badApp = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityThread.java*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ApplicationThread</span> <span class="keyword">extends</span> <span class="title class_">IApplicationThread</span>.Stub &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bindApplication</span><span class="params">(...)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">AppBindData</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppBindData</span>();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 向应用进程主线程Handler发送BIND_APPLICATION消息，触发在应用主线程执行handleBindApplication初始化动作</span></span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">           <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                    <span class="type">AppBindData</span> <span class="variable">data</span> <span class="operator">=</span> (AppBindData)msg.obj;</span><br><span class="line">                    <span class="comment">// 在应用主线程执行handleBindApplication初始化动作</span></span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    ...</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindApplication</span><span class="params">(AppBindData data)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码流程可以看出：**<code>AMS</code>服务在执行应用的<code>attachApplication</code>注册请求过程中，会通过<code>oneway</code>类型的<code>binder</code>调用应用进程<code>ActivityThread#IApplicationThread</code>的<code>bindApplication</code>接口，而<code>bindApplication</code>接口函数实现中又会通过往应用主线程消息队列post** <strong><code>BIND_APPLICATION</code>消息触发执行<code>handleBindApplication</code>初始化函数</strong>，从systrace看如下图所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-2891d7a66084e2a6bba2f8e399c54a6a_1440w.webp" alt="img"></p>
<p>我们继续结合代码看看handleBindApplication的简化关键流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityThread.java*/</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindApplication</span><span class="params">(AppBindData data)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.创建应用的LoadedApk对象</span></span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2.创建应用Application的Context、触发Art虚拟机加载应用APK的Dex文件到内存中，并加载应用APK的Resource资源</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ContextImpl</span> <span class="variable">appContext</span> <span class="operator">=</span> ContextImpl.createAppContext(<span class="built_in">this</span>, data.info);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3.调用LoadedApk的makeApplication函数，实现创建应用的Application对象</span></span><br><span class="line">    app = data.info.makeApplication(data.restrictedBackupMode, <span class="literal">null</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 4.执行应用Application#onCreate生命周期函数</span></span><br><span class="line">    mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ActivityThread#**handleBindApplication</code>初始化过程中在应用主线程中主要完成如下几件事件**：</p>
<ol>
<li>根据框架传入的<code>ApplicationInfo</code>信息创建应用<code>APK</code>对应的<code>LoadedApk</code>对象;</li>
<li>创建应用<code>Application</code>的<code>Context</code>对象；</li>
<li><strong>创建类加载器<code>ClassLoader</code>对象并触发<code>Art</code>虚拟机执行<code>OpenDexFilesFromOat</code>动作加载应用<code>APK</code>的<code>Dex</code>文件</strong>；</li>
<li><strong>通过<code>LoadedApk</code>加载应用<code>APK</code>的<code>Resource</code>资源</strong>；</li>
<li>调用<code>LoadedApk</code>的<code>makeApplication</code>函数，创建应用的<code>Application</code>对象;</li>
<li><strong>执行应用<code>Application#onCreate</code>生命周期函数</strong>（<code>APP</code>应用开发者能控制的第一行代码）;</li>
</ol>
<p>下面我们结合代码重点看看<code>APK Dex</code>文件的加载和<code>Resource</code>资源的加载流程。</p>
<h3 id="2-应用APK的Dex文件加载"><a href="#2-应用APK的Dex文件加载" class="headerlink" title="2.应用APK的Dex文件加载"></a>2.应用APK的Dex文件加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ContextImpl.java*/</span></span><br><span class="line"><span class="keyword">static</span> ContextImpl <span class="title function_">createAppContext</span><span class="params">(ActivityThread mainThread, LoadedApk packageInfo,</span></span><br><span class="line"><span class="params">            String opPackageName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (packageInfo == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;packageInfo&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.创建应用Application的Context对象</span></span><br><span class="line">    <span class="type">ContextImpl</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContextImpl</span>(<span class="literal">null</span>, mainThread, packageInfo, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="literal">null</span>, opPackageName);</span><br><span class="line">    <span class="comment">// 2.触发加载APK的DEX文件和Resource资源</span></span><br><span class="line">    context.setResources(packageInfo.getResources());</span><br><span class="line">    context.mIsSystemOrSystemUiContext = isSystemOrSystemUI(context);</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/LoadedApk.java*/</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> Resources <span class="title function_">getResources</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (mResources == <span class="literal">null</span>) &#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 加载APK的Resource资源</span></span><br><span class="line">         mResources = ResourcesManager.getInstance().getResources(<span class="literal">null</span>, mResDir,</span><br><span class="line">                    splitPaths, mOverlayDirs, mApplicationInfo.sharedLibraryFiles,</span><br><span class="line">                    Display.DEFAULT_DISPLAY, <span class="literal">null</span>, getCompatibilityInfo(),</span><br><span class="line">                    getClassLoader()<span class="comment">/*触发加载APK的DEX文件*/</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> mResources;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">             createOrUpdateClassLoaderLocked(<span class="literal">null</span> <span class="comment">/*addedPaths*/</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> mClassLoader;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createOrUpdateClassLoaderLocked</span><span class="params">(List&lt;String&gt; addedPaths)</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span> (mDefaultClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">// 创建默认的mDefaultClassLoader对象，触发art虚拟机加载dex文件</span></span><br><span class="line">          mDefaultClassLoader = ApplicationLoaders.getDefault().getClassLoaderWithSharedLibraries(</span><br><span class="line">                    zip, mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,</span><br><span class="line">                    libraryPermittedPath, mBaseClassLoader,</span><br><span class="line">                    mApplicationInfo.classLoaderName, sharedLibraries);</span><br><span class="line">          ...</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span> (mClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 赋值给mClassLoader对象</span></span><br><span class="line">         mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ApplicationInfo</span>(mApplicationInfo));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ApplicationLoaders.java*/</span></span><br><span class="line">ClassLoader <span class="title function_">getClassLoaderWithSharedLibraries</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="comment">// For normal usage the cache key used is the same as the zip path.</span></span><br><span class="line">    <span class="keyword">return</span> getClassLoader(zip, targetSdkVersion, isBundled, librarySearchPath,</span><br><span class="line">                              libraryPermittedPath, parent, zip, classLoaderName, sharedLibraries);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">(String zip, ...)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">synchronized</span> (mLoaders) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (parent == baseParent) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 1.创建BootClassLoader加载系统框架类，并增加相应的systrace tag</span></span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">classloader</span> <span class="operator">=</span> ClassLoaderFactory.createClassLoader(</span><br><span class="line">                        zip,  librarySearchPath, libraryPermittedPath, parent,</span><br><span class="line">                        targetSdkVersion, isBundled, classLoaderName, sharedLibraries);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> classloader;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.创建PathClassLoader加载应用APK的Dex类，并增加相应的systrace tag</span></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> ClassLoaderFactory.createClassLoader(</span><br><span class="line">                    zip, <span class="literal">null</span>, parent, classLoaderName, sharedLibraries);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">return</span> loader;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/com/android/internal/os/ClassLoaderFactory.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title function_">createClassLoader</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过new的方式创建ClassLoader对象，最终会触发art虚拟机加载APK的dex文件</span></span><br><span class="line">        ClassLoader[] arrayOfSharedLibraries = (sharedLibraries == <span class="literal">null</span>)</span><br><span class="line">                ? <span class="literal">null</span></span><br><span class="line">                : sharedLibraries.toArray(<span class="keyword">new</span> <span class="title class_">ClassLoader</span>[sharedLibraries.size()]);</span><br><span class="line">        <span class="keyword">if</span> (isPathClassLoaderName(classloaderName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PathClassLoader</span>(dexPath, librarySearchPath, parent, arrayOfSharedLibraries);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出：在创建<code>Application</code>的<code>Context</code>对象后会立马尝试去加载<code>APK</code>的<code>Resource</code>资源，而在这之前需要通过<code>LoadedApk</code>去创建类加载器<code>ClassLoader</code>对象，而这个过程最终就会触发<code>Art</code>虚拟机加载应用<code>APK</code>的<code>dex</code>文件，从systrace上看如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/08/aUTrylHmL1N7vDW.webp" alt="img"></p>
<p>具体art虚拟机加载dex文件的流程由于篇幅所限这里就不展开讲了，这边画了一张流程图可以参考一下，感兴趣的读者可以对照追一下源码流程：</p>
<p><img src="https://s2.loli.net/2023/09/08/T1yPn8VH4Yd5FCv.webp" alt="img"></p>
<h3 id="3-应用APK的Resource资源加载"><a href="#3-应用APK的Resource资源加载" class="headerlink" title="3 应用APK的Resource资源加载"></a>3 应用APK的Resource资源加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/LoadedApk.java*/</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> Resources <span class="title function_">getResources</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (mResources == <span class="literal">null</span>) &#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 加载APK的Resource资源</span></span><br><span class="line">         mResources = ResourcesManager.getInstance().getResources(<span class="literal">null</span>, mResDir,</span><br><span class="line">                    splitPaths, mOverlayDirs, mApplicationInfo.sharedLibraryFiles,</span><br><span class="line">                    Display.DEFAULT_DISPLAY, <span class="literal">null</span>, getCompatibilityInfo(),</span><br><span class="line">                    getClassLoader()<span class="comment">/*触发加载APK的DEX文件*/</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> mResources;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ResourcesManager.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> Resources <span class="title function_">getResources</span><span class="params">(...)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 原生Resource资源加载的systrace tag</span></span><br><span class="line">          Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, <span class="string">&quot;ResourcesManager#getResources&quot;</span>);</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">return</span> createResources(activityToken, key, classLoader, assetsSupplier);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> Resources <span class="title function_">createResources</span><span class="params">(...)</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 执行创建Resources资源对象</span></span><br><span class="line">            <span class="type">ResourcesImpl</span> <span class="variable">resourcesImpl</span> <span class="operator">=</span> findOrCreateResourcesImplForKeyLocked(key, apkSupplier);</span><br><span class="line">            <span class="keyword">if</span> (resourcesImpl == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ResourcesImpl <span class="title function_">findOrCreateResourcesImplForKeyLocked</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> ResourcesKey key, <span class="meta">@Nullable</span> ApkAssetsSupplier apkSupplier)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      impl = createResourcesImpl(key, apkSupplier);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ResourcesImpl <span class="title function_">createResourcesImpl</span><span class="params">(<span class="meta">@NonNull</span> ResourcesKey key,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> ApkAssetsSupplier apkSupplier)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 创建AssetManager对象，真正实现的APK文件加载解析动作</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AssetManager</span> <span class="variable">assets</span> <span class="operator">=</span> createAssetManager(key, apkSupplier);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> AssetManager <span class="title function_">createAssetManager</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> ResourcesKey key,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> ApkAssetsSupplier apkSupplier)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = apkKeys.size(); i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ApkKey</span> <span class="variable">apkKey</span> <span class="operator">=</span> apkKeys.get(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过loadApkAssets实现应用APK文件的加载</span></span><br><span class="line">                builder.addApkAssets(</span><br><span class="line">                        (apkSupplier != <span class="literal">null</span>) ? apkSupplier.load(apkKey) : loadApkAssets(apkKey));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@NonNull</span> ApkAssets <span class="title function_">loadApkAssets</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> ApkKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (key.overlay) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 通过ApkAssets从APK文件所在的路径去加载</span></span><br><span class="line">            apkAssets = ApkAssets.loadFromPath(key.path,</span><br><span class="line">                    key.sharedLib ? ApkAssets.PROPERTY_DYNAMIC : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/content/res/ApkAssets.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@NonNull</span> ApkAssets <span class="title function_">loadFromPath</span><span class="params">(<span class="meta">@NonNull</span> String path, <span class="meta">@PropertyFlags</span> <span class="type">int</span> flags)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApkAssets</span>(FORMAT_APK, path, flags, <span class="literal">null</span> <span class="comment">/* assets */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ApkAssets</span><span class="params">(<span class="meta">@FormatType</span> <span class="type">int</span> format, <span class="meta">@NonNull</span> String path, <span class="meta">@PropertyFlags</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> AssetsProvider assets)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通过JNI调用Native层的系统system/lib/libandroidfw.so库中的相关C函数实现对APK文件压缩包的解析与加载</span></span><br><span class="line">        mNativePtr = nativeLoad(format, path, flags, assets);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出：<strong>系统对于应用<code>APK</code>文件资源的加载过程其实就是创建应用进程中的<code>Resources</code>资源对象的过程，其中真正实现<code>APK</code>资源文件的<code>I/O</code>解析作，最终是借助于<code>AssetManager</code>中通过JNI调用系统<code>Native</code>层的相关<code>C</code>函数实现。</strong>整个过程从systrace上看如下图所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-895384d78c96f31a031138a0b7007b50_1440w.webp" alt="img"></p>
<h2 id="三-Activity的创建与初始化"><a href="#三-Activity的创建与初始化" class="headerlink" title="三.Activity的创建与初始化"></a>三.Activity的创建与初始化</h2><p>我们回到6.1小结中，看看<code>AMS</code>在收到应用进程的<code>attachApplication</code>注册请求后，先通过oneway类型的binder调用应用及进程的<code>IApplicationThread</code>#<code>bindApplication</code>接口，触发应用进程在主线程执行<code>handleBindeApplication</code>初始化操作，然后继续执行启动应用<code>Activity</code>的操作，下面我们来看看系统是如何启动创建应用<code>Activity</code>的，简化代码流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java*/</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(...)</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span> (app.isolatedEntryPoint != <span class="literal">null</span>) &#123;</span><br><span class="line">           ...</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 1.通过oneway异步类型的binder调用应用进程ActivityThread#IApplicationThread#bindApplication接口</span></span><br><span class="line">           thread.bindApplication(...);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           thread.bindApplication(...);</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// See if the top visible activity is waiting to run in this process...</span></span><br><span class="line">     <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.继续执行启动应用Activity的流程</span></span><br><span class="line">            didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, <span class="string">&quot;Exception thrown launching activities in &quot;</span> + app, e);</span><br><span class="line">                badApp = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">attachApplication</span><span class="params">(WindowProcessController wpc)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (mGlobalLockWithoutBoost) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) &#123;</span><br><span class="line">                <span class="comment">// 原生标识attachApplication过程的systrace tag</span></span><br><span class="line">                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;attachApplication:&quot;</span> + wpc.mName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mRootWindowContainer.attachApplication(wpc);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/services/core/java/com/android/server/wm/RootWindowContainer.java*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">attachApplication</span><span class="params">(WindowProcessController app)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">final</span> <span class="type">PooledFunction</span> <span class="variable">c</span> <span class="operator">=</span> PooledLambda.obtainFunction(</span><br><span class="line">                <span class="comment">// startActivityForAttachedApplicationIfNeeded执行启动应用Activity流程</span></span><br><span class="line">                RootWindowContainer::startActivityForAttachedApplicationIfNeeded, <span class="built_in">this</span>,</span><br><span class="line">                PooledLambda.__(ActivityRecord.class), app,</span><br><span class="line">                rootTask.topRunningActivity());</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">startActivityForAttachedApplicationIfNeeded</span><span class="params">(ActivityRecord r,</span></span><br><span class="line"><span class="params">            WindowProcessController app, ActivityRecord top)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ActivityStackSupervisor的realStartActivityLocked真正实现启动应用Activity流程</span></span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.realStartActivityLocked(r, app,</span><br><span class="line">                    top == r &amp;&amp; r.isFocusable() <span class="comment">/*andResume*/</span>, <span class="literal">true</span> <span class="comment">/*checkConfig*/</span>)) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            ..</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> andResume, <span class="type">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">         ...</span><br><span class="line">        <span class="comment">// 1.先通过LaunchActivityItem封装Binder通知应用进程执行Launch Activity动作       </span></span><br><span class="line">         clientTransaction.addCallback(LaunchActivityItem.obtain(...);</span><br><span class="line">         <span class="comment">// Set desired final state.</span></span><br><span class="line">         <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">         <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                <span class="comment">// 2.再通过ResumeActivityItem封装Binder通知应用进程执行Launch Resume动作        </span></span><br><span class="line">                lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">         clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line">         <span class="comment">// 执行以上封装的Binder调用</span></span><br><span class="line">         mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">         ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码分析可以看到，框架<code>system_server</code>进程最终是通过<code>ActivityStackSupervisor</code>#<code>realStartActivityLocked</code>函数中，通过<code>LaunchActivityItem</code>和<code>ResumeActivityItem</code>两个类的封装，依次实现binder调用通知应用进程这边执行<code>Activity</code>的Launch和Resume动作的，我们继续往下看相关代码流程：</p>
<h3 id="1-Activity-Create"><a href="#1-Activity-Create" class="headerlink" title="1 Activity Create"></a>1 Activity Create</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span><br><span class="line"><span class="params">            PendingTransactionActions pendingActions)</span> &#123;</span><br><span class="line">     <span class="comment">// 原生标识Activity Launch的systrace tag</span></span><br><span class="line">     Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityStart&quot;</span>);</span><br><span class="line">     <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityClientRecord</span>(token, mIntent, mIdent, mInfo,</span><br><span class="line">                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">                mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">                mProfilerInfo, client, mAssistToken, mFixedRotationAdjustments);</span><br><span class="line">     <span class="comment">// 调用到ActivityThread的handleLaunchActivity函数在主线程执行应用Activity的Launch创建动作</span></span><br><span class="line">     client.handleLaunchActivity(r, pendingActions, <span class="literal">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">     Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityThread.java*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Activity <span class="title function_">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span><br><span class="line"><span class="params">            PendingTransactionActions pendingActions, Intent customIntent)</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> performLaunchActivity(r, customIntent);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  Core implementation of activity launch. */</span></span><br><span class="line"><span class="keyword">private</span> Activity <span class="title function_">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 1.创建Activity的Context</span></span><br><span class="line">        <span class="type">ContextImpl</span> <span class="variable">appContext</span> <span class="operator">=</span> createBaseContextForActivity(r);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.反射创建Activity对象</span></span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 3.执行Activity的attach动作</span></span><br><span class="line">                activity.attach(...);</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 4.执行应用Activity的onCreate生命周期函数,并在setContentView调用中创建DecorView对象</span></span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/Activity.java*/</span></span><br><span class="line"> <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(...)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 1.创建表示应用窗口的PhoneWindow对象</span></span><br><span class="line">        mWindow = <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(<span class="built_in">this</span>, window, activityConfigCallback);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 2.为PhoneWindow配置WindowManager</span></span><br><span class="line">        mWindow.setWindowManager(</span><br><span class="line">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">                mToken, mComponent.flattenToString(),</span><br><span class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，应用进程这边在收到系统binder调用后，<strong>在主线程中创建<code>Activiy</code>的流程主要步骤如下</strong>：</p>
<ol>
<li>创建<code>Activity</code>的<code>Context</code>；</li>
<li>通过反射创建<code>Activity</code>对象；</li>
<li>执行<code>Activity</code>的<code>attach</code>动作，**其中会创建应用窗口的<code>PhoneWindow</code>对象并设置<code>WindowManage</code>**；</li>
<li><strong>执行应用<code>Activity</code>的<code>onCreate</code>生命周期函数，并在<code>setContentView</code>中创建窗口的<code>DecorView</code>对象</strong>；</li>
</ol>
<p>从systrace上看整个过程如下图所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-afc6216fbc4e4631ddc8a5c1ba5b348b_1440w.webp" alt="img"></p>
<h3 id="2-Activity-Resume"><a href="#2-Activity-Resume" class="headerlink" title="2 Activity Resume"></a>2 Activity Resume</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/servertransaction/ResumeActivityItem.java*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span><br><span class="line"><span class="params">            PendingTransactionActions pendingActions)</span> &#123;</span><br><span class="line">   <span class="comment">// 原生标识Activity Resume的systrace tag</span></span><br><span class="line">   Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityResume&quot;</span>);</span><br><span class="line">   client.handleResumeActivity(token, <span class="literal">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward,</span><br><span class="line">                <span class="string">&quot;RESUME_ACTIVITY&quot;</span>);</span><br><span class="line">   Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityThread.java*/</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(...)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.执行performResumeActivity流程,执行应用Activity的onResume生命周期函数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">// 2.执行WindowManager#addView动作开启视图绘制逻辑</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ActivityClientRecord <span class="title function_">performResumeActivity</span><span class="params">(...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 执行应用Activity的onResume生命周期函数</span></span><br><span class="line">    r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/view/WindowManagerGlobal.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(...)</span> &#123;</span><br><span class="line">     <span class="comment">// 创建ViewRootImpl对象</span></span><br><span class="line">     root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 执行ViewRootImpl的setView函数</span></span><br><span class="line">         root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，应用进程这边在接收到系统Binder调用请求后，<strong>在主线程中<code>Activiy</code></strong> <strong><code>Resume</code>的流程主要步骤如下</strong>：</p>
<ol>
<li><strong>执行应用<code>Activity</code>的<code>onResume</code>生命周期函数</strong>;</li>
<li>执行<code>WindowManager</code>的<code>addView</code>动作开启视图绘制逻辑;</li>
<li>创建<code>Activity</code>的<code>ViewRootImpl</code>对象;</li>
<li><strong>执行<code>ViewRootImpl</code>的<code>setView</code>函数开启UI界面绘制动作</strong>；</li>
</ol>
<p>从systrace上看整个过程如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/08/sVKILqGeirl3Wty.webp" alt="img"></p>
<h2 id="四-应用UI布局与绘制"><a href="#四-应用UI布局与绘制" class="headerlink" title="四. 应用UI布局与绘制"></a>四. 应用UI布局与绘制</h2><p>接上一节的分析，应用主线程中在执行<code>Activity</code>的Resume流程的最后，会创建<code>ViewRootImpl</code>对象并调用其setView函数，从此并开启了应用界面UI布局与绘制的流程。在开始讲解这个过程之前，我们先来整理一下前面代码中讲到的这些概念，如<code>Activity</code>、<code>PhoneWindow</code>、<code>DecorView</code>、<code>ViewRootImpl</code>、<code>WindowManager</code>它们之间的关系与职责，因为这些核心类基本构成了Android系统的GUI显示系统在应用进程侧的核心架构，其整体架构如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/08/ugMrZlQSmj6hUeL.webp" alt="img"></p>
<ul>
<li><code>Window</code>是一个抽象类，**通过控制<code>DecorView</code>提供了一些标准的UI方案，比如<code>背景、标题、虚拟按键等</code>**，而<code>PhoneWindow</code>是<code>Window</code>的唯一实现类，在<code>Activity</code>创建后的attach流程中创建，应用启动显示的内容装载到其内部的<code>mDecor</code>（<code>DecorView</code>）；</li>
<li><code>DecorView</code>是整个界面布局View控件树的根节点，通过它可以遍历访问到整个View控件树上的任意节点；</li>
<li><code>WindowManager</code>是一个接口，继承自<code>ViewManager</code>接口，提供了<code>View</code>的基本操作方法；<code>WindowManagerImp</code>实现了<code>WindowManager</code>接口，内部通过<code>组合</code>方式持有<code>WindowManagerGlobal</code>，用来操作<code>View</code>；**<code>WindowManagerGlobal</code>是一个全局单例，内部可以通过<code>ViewRootImpl</code>将<code>View</code>添加至<code>窗口</code>中**；</li>
<li><strong><code>ViewRootImpl</code>是所有<code>View</code>的<code>Parent</code>，用来总体管理<code>View</code>的绘制以及与系统<code>WMS</code>窗口管理服务的IPC交互从而实现<code>窗口</code>的开辟</strong>；<code>ViewRootImpl</code>是应用进程运转的发动机，可以看到<code>ViewRootImpl</code>内部包含<code>mView</code>（就是<code>DecorView</code>）、<code>mSurface</code>、<code>Choregrapher</code>，<code>mView</code>代表整个控件树，<code>mSurfacce</code>代表画布，应用的UI渲染会直接放到<code>mSurface</code>中，<code>Choregorapher</code>使得应用请求<code>vsync</code>信号，接收信号后开始渲染流程；<br>我们从<code>ViewRootImpl</code>的setView流程继续结合代码往下看：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/view/ViewRootImpl.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mView == <span class="literal">null</span>) &#123;</span><br><span class="line">             mView = view;</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 开启绘制硬件加速，初始化RenderThread渲染线程运行环境</span></span><br><span class="line">         enableHardwareAcceleration(attrs);</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 1.触发绘制动作</span></span><br><span class="line">         requestLayout();</span><br><span class="line">         ...</span><br><span class="line">         inputChannel = <span class="keyword">new</span> <span class="title class_">InputChannel</span>();</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 2.Binder调用访问系统窗口管理服务WMS接口，实现addWindow添加注册应用窗口的操作,并传入inputChannel用于接收触控事件</span></span><br><span class="line">         res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame,</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mDisplayCutout, inputChannel,</span><br><span class="line">                            mTempInsets, mTempControls);</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 3.创建WindowInputEventReceiver对象，实现应用窗口接收触控事件</span></span><br><span class="line">         mInputEventReceiver = <span class="keyword">new</span> <span class="title class_">WindowInputEventReceiver</span>(inputChannel,</span><br><span class="line">                            Looper.myLooper());</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 4.设置DecorView的mParent为ViewRootImpl</span></span><br><span class="line">         view.assignParent(<span class="built_in">this</span>);</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出<code>ViewRootImpl</code>的setView内部关键流程如下：</p>
<ol>
<li><strong>requestLayout()通过一系列调用触发界面绘制（measure、layout、draw）动作</strong>，下文会详细展开分析；</li>
<li><strong>通过Binder调用访问系统窗口管理服务<code>WMS</code>的<code>addWindow</code>接口</strong>，<strong>实现添加、注册应用窗口的操作</strong>，并传入本地创建inputChannel对象用于后续接收系统的触控事件，这一步执行完我们的<code>View</code>就可以显示到屏幕上了。关于<code>WMS</code>的内部实现流程也非常复杂，由于篇幅有限本文就不详细展开分析了。</li>
<li>创建WindowInputEventReceiver对象，封装实现应用窗口接收系统触控事件的逻辑；</li>
<li>执行view.assignParent(this)，设置<code>DecorView</code>的mParent为<code>ViewRootImpl</code>。所以，<strong>虽然<code>ViewRootImpl</code>不是一个<code>View</code>,但它是所有<code>View</code>的顶层<code>Parent</code>。</strong></li>
</ol>
<p>我们顺着<code>ViewRootImpl</code>的<code>requestLayout</code>动作继续往下看界面绘制的流程代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/view/ViewRootImpl.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">         <span class="comment">// 检查当前UI绘制操作是否发生在主线程，如果发生在子线程则会抛出异常</span></span><br><span class="line">         checkThread();</span><br><span class="line">         mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">         <span class="comment">// 触发绘制操作</span></span><br><span class="line">         scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 注意此处会往主线程的MessageQueue消息队列中添加同步栏删，因为系统绘制消息属于异步消息，需要更高优先级的处理</span></span><br><span class="line">         mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">         <span class="comment">// 通过Choreographer往主线程消息队列添加CALLBACK_TRAVERSAL绘制类型的待执行消息，用于触发后续UI线程真正实现绘制动作</span></span><br><span class="line">         mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Choreographer</code> 的引入，主要是配合系统<code>Vsync</code>垂直同步机制（Android“黄油计划”中引入的机制之一，协调APP生成UI数据和<code>SurfaceFlinger</code>合成图像，避免Tearing画面撕裂的现象），给上层 App 的渲染提供一个稳定的 <code>Message</code> 处理的时机，也就是 <code>Vsync</code> 到来的时候 ，系统通过对 <code>Vsync</code> 信号周期的调整，来控制每一帧绘制操作的时机。<code>**Choreographer**</code> <strong>扮演 Android 渲染链路中承上启下的角色</strong>：</p>
<ol>
<li><strong>承上</strong>：负责接收和处理 App 的各种更新消息和回调，等到 <code>Vsync</code> 到来的时候统一处理。比如集中处理 Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 <code>measure、layout、draw</code> 等操作) ，判断卡顿掉帧情况，记录 CallBack 耗时等；</li>
<li><strong>启下</strong>：负责请求和接收 Vsync 信号。接收 Vsync 事件回调(通过 <code>FrameDisplayEventReceiver</code>.<code>onVsync</code> )，请求 <code>Vsync</code>(<code>FrameDisplayEventReceiver</code>.<code>scheduleVsync</code>) 。</li>
</ol>
<p><code>Choreographer</code>在收到<code>CALLBACK_TRAVERSAL</code>类型的绘制任务后，其内部的工作流程如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/08/1EDGx9qaoJrw4BX.webp" alt="img"></p>
<p>从以上流程图可以看出：<code>ViewRootImpl</code>调用<code>Choreographer</code>的<code>postCallback</code>接口放入待执行的绘制消息后，<code>Choreographer</code>会先向系统申请<code>APP</code> 类型的<code>vsync</code>信号，然后等待系统<code>vsync</code>信号到来后，去回调到<code>ViewRootImpl</code>的<code>doTraversal</code>函数中执行真正的绘制动作（measure、layout、draw）。这个绘制过程从systrace上看如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/08/qm3Ml6I9kNE1JyT.webp" alt="img"></p>
<p>我们接着<code>ViewRootImpl</code>的<code>doTraversal</code>函数的简化代码流程往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/view/ViewRootImpl.java*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">         mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">         <span class="comment">// 调用removeSyncBarrier及时移除主线程MessageQueue中的Barrier同步栏删，以避免主线程发生“假死”</span></span><br><span class="line">         mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 执行具体的绘制任务</span></span><br><span class="line">         performTraversals();</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 1.从DecorView根节点出发，遍历整个View控件树，完成整个View控件树的measure测量操作</span></span><br><span class="line">     windowSizeMayChange |= measureHierarchy(...);</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span> (mFirst...) &#123;</span><br><span class="line">    <span class="comment">// 2.第一次执行traversals绘制任务时，Binder调用访问系统窗口管理服务WMS的relayoutWindow接口，实现WMS计算应用窗口尺寸并向系统surfaceflinger正式申请Surface“画布”操作</span></span><br><span class="line">         relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 3.从DecorView根节点出发，遍历整个View控件树，完成整个View控件树的layout测量操作</span></span><br><span class="line">     performLayout(lp, mWidth, mHeight);</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 4.从DecorView根节点出发，遍历整个View控件树，完成整个View控件树的draw测量操作</span></span><br><span class="line">     performDraw();</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通过Binder IPC访问系统WMS服务的relayout接口，申请Surface“画布”操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">relayoutResult</span> <span class="operator">=</span> mWindowSession.relayout(mWindow, mSeq, params,</span><br><span class="line">                (<span class="type">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">                (<span class="type">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>), viewVisibility,</span><br><span class="line">                insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>, frameNumber,</span><br><span class="line">                mTmpFrame, mTmpRect, mTmpRect, mTmpRect, mPendingBackDropFrame,</span><br><span class="line">                mPendingDisplayCutout, mPendingMergedConfiguration, mSurfaceControl, mTempInsets,</span><br><span class="line">                mTempControls, mSurfaceSize, mBlastSurfaceControl);</span><br><span class="line">        <span class="keyword">if</span> (mSurfaceControl.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!useBLAST()) &#123;</span><br><span class="line">                <span class="comment">// 本地Surface对象获取指向远端分配的Surface的引用</span></span><br><span class="line">                mSurface.copyFrom(mSurfaceControl);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performMeasure</span><span class="params">(<span class="type">int</span> childWidthMeasureSpec, <span class="type">int</span> childHeightMeasureSpec)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 原生标识View树的measure测量过程的trace tag</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;measure&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从mView指向的View控件树的根节点DecorView出发，遍历访问整个View树，并完成整个布局View树的测量工作</span></span><br><span class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performDraw</span><span class="params">()</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">canUseAsync</span> <span class="operator">=</span> draw(fullRedrawNeeded);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">draw</span><span class="params">(<span class="type">boolean</span> fullRedrawNeeded)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="literal">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 如果开启并支持硬件绘制加速，则走硬件绘制的流程（从Android 4.+开始，默认情况下都是支持跟开启了硬件加速的）</span></span><br><span class="line">        mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则走drawSoftware软件绘制的流程</span></span><br><span class="line">        <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                        scalingRequired, dirty, surfaceInsets)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码流程可以看出，**<code>ViewRootImpl</code>中负责的整个应用界面绘制的主要流程如下**：</p>
<ol>
<li>从界面View控件树的根节点<code>DecorView</code>出发，递归遍历整个View控件树，完成对整个<code>View</code>控件树的<code>measure</code>测量操作，由于篇幅所限，本文就不展开分析这块的详细流程；</li>
<li>界面第一次执行绘制任务时，会通过<code>Binder``IPC</code>访问系统窗口管理服务WMS的relayout接口，实现窗口尺寸的计算并向系统申请用于本地绘制渲染的Surface“画布”的操作（<strong>具体由<code>SurfaceFlinger</code>负责创建应用界面对应的<code>BufferQueueLayer</code>对象，并通过内存共享的方式通过<code>Binder</code>将地址引用透过WMS回传给应用进程这边</strong>），由于篇幅所限，本文就不展开分析这块的详细流程；</li>
<li>从界面View控件树的根节点<code>DecorView</code>出发，递归遍历整个View控件树，完成对整个<code>View</code>控件树的<code>layout</code>测量操作；</li>
<li>从界面View控件树的根节点<code>DecorView</code>出发，递归遍历整个<code>View</code>控件树，完成对整个<code>View</code>控件树的<code>draw</code>测量操作，<strong>如果开启并支持硬件绘制加速（从Android 4.X开始谷歌已经默认开启硬件加速），则走<code>GPU</code>硬件绘制的流程，否则走<code>CPU</code>软件绘制的流程</strong>；</li>
</ol>
<p>以上绘制过程从systrace上看如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/08/BKxDrqPcsoIeAuj.webp" alt="img"></p>
<p><img src="https://s2.loli.net/2023/09/08/TkZWj4pM3lXrRuQ.webp" alt="img"></p>
<p>借用一张图来总结应用UI绘制的流程，如下所示：</p>
<p><img src="https://s2.loli.net/2023/09/08/gTRqKBiE3phCZSu.webp" alt="img"></p>
<h2 id="五-RenderThread渲染"><a href="#五-RenderThread渲染" class="headerlink" title="五. RenderThread渲染"></a>五. RenderThread渲染</h2><p>截止到目前，在<code>ViewRootImpl</code>中完成了对界面的measure、layout和draw等绘制流程后，用户依然还是看不到屏幕上显示的应用界面内容，因为整个<code>Android</code>系统的显示流程除了前面讲到的UI线程的绘制外，界面还需要经过<code>RenderThread</code>线程的渲染处理，渲染完成后，还需要通过<code>Binder</code>调用“上帧”交给<code>surfaceflinger</code>进程中进行合成后送显才能最终显示到屏幕上。本小节中，我们将接上一节中<code>ViewRootImpl</code>中最后draw的流程继续往下分析开启硬件加速情况下，<code>RenderThread</code>渲染线程的工作流程。由于目前Android 4.X之后系统默认界面是开启硬件加速的，所以本文我们重点分析硬件加速条件下的界面渲染流程，我们先分析一下简化的代码流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/view/ViewRootImpl.java*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">draw</span><span class="params">(<span class="type">boolean</span> fullRedrawNeeded)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="literal">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 硬件加速条件下的界面渲染流程</span></span><br><span class="line">        mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/view/ThreadedRenderer.java*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.从DecorView根节点出发，递归遍历View控件树，记录每个View节点的绘制操作命令，完成绘制操作命令树的构建</span></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2.JNI调用同步Java层构建的绘制命令树到Native层的RenderThread渲染线程，并唤醒渲染线程利用OpenGL执行渲染任务；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">syncResult</span> <span class="operator">=</span> syncAndDrawFrame(choreographer.mFrameInfo);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，<strong>硬件加速绘制主要包括两个阶段</strong>：</p>
<ol>
<li>从<code>DecorView</code>根节点出发，递归遍历<code>View</code>控件树，记录每个<code>View</code>节点的<code>drawOp</code>绘制操作命令，完成绘制操作命令树的构建；</li>
<li><code>JNI</code>调用同步<code>Java</code>层构建的绘制命令树到<code>Native</code>层的<code>RenderThread</code>渲染线程，并唤醒渲染线程利用<code>OpenGL</code>执行渲染任务；</li>
</ol>
<h3 id="1-构建绘制命令树"><a href="#1-构建绘制命令树" class="headerlink" title="1 构建绘制命令树"></a>1 构建绘制命令树</h3><p>我们先来看看第一阶段构建绘制命令树的代码简化流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/view/ThreadedRenderer.java*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRootDisplayList</span><span class="params">(View view, DrawCallbacks callbacks)</span> &#123;</span><br><span class="line">        <span class="comment">// 原生标记构建View绘制操作命令树过程的systrace tag</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Record View#draw()&quot;</span>);</span><br><span class="line">        <span class="comment">// 递归子View的updateDisplayListIfDirty实现构建DisplayListOp</span></span><br><span class="line">        updateViewTreeDisplayList(view);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123;</span><br><span class="line">            <span class="comment">// 获取根View的SkiaRecordingCanvas</span></span><br><span class="line">            <span class="type">RecordingCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 利用canvas缓存DisplayListOp绘制命令</span></span><br><span class="line">                canvas.drawRenderNode(view.updateDisplayListIfDirty());</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 将所有DisplayListOp绘制命令填充到RootRenderNode中</span></span><br><span class="line">                mRootNode.endRecording();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateViewTreeDisplayList</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 从DecorView根节点出发，开始递归调用每个View树节点的updateDisplayListIfDirty函数</span></span><br><span class="line">        view.updateDisplayListIfDirty();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/view/View.java*/</span></span><br><span class="line"><span class="keyword">public</span> RenderNode <span class="title function_">updateDisplayListIfDirty</span><span class="params">()</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 1.利用`View`对象构造时创建的`RenderNode`获取一个`SkiaRecordingCanvas`“画布”；</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">RecordingCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> renderNode.beginRecording(width, height);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">              <span class="comment">// 如果仅仅是ViewGroup，并且自身不用绘制，直接递归子View</span></span><br><span class="line">              dispatchDraw(canvas);</span><br><span class="line">              ...</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 2.利用SkiaRecordingCanvas，在每个子View控件的onDraw绘制函数中调用drawLine、drawRect等绘制操作时，创建对应的DisplayListOp绘制命令，并缓存记录到其内部的SkiaDisplayList持有的DisplayListData中；</span></span><br><span class="line">              draw(canvas);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 3.将包含有`DisplayListOp`绘制命令缓存的`SkiaDisplayList`对象设置填充到`RenderNode`中；</span></span><br><span class="line">         renderNode.endRecording();</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// draw the content(View自己实现的onDraw绘制，由应用开发者自己实现)</span></span><br><span class="line">    onDraw(canvas);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/graphics/java/android/graphics/RenderNode.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">endRecording</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 从SkiaRecordingCanvas中获取SkiaDisplayList对象</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">displayList</span> <span class="operator">=</span> canvas.finishRecording();</span><br><span class="line">        <span class="comment">// 将SkiaDisplayList对象填充到RenderNode中</span></span><br><span class="line">        nSetDisplayList(mNativeRenderNode, displayList);</span><br><span class="line">        canvas.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，<strong>构建绘制命令树的过程是从<code>View</code>控件树的根节点<code>DecorView</code>触发，递归调用每个子<code>View</code>节点的<code>updateDisplayListIfDirty</code>函数，最终完成绘制树的创建，简述流程如下</strong>：</p>
<ol>
<li>利用<code>View</code>对象构造时创建的<code>RenderNode</code>获取一个<code>SkiaRecordingCanvas</code>“画布”；</li>
<li>利用<code>SkiaRecordingCanvas</code>，<strong>在每个子<code>View</code>控件的<code>onDraw</code>绘制函数中调用<code>drawLine</code>、<code>drawRect</code>等绘制操作时，创建对应的<code>DisplayListOp</code>绘制命令，并缓存记录到其内部的<code>SkiaDisplayList</code>持有的<code>DisplayListData</code>中</strong>；</li>
<li>将包含有<code>DisplayListOp</code>绘制命令缓存的<code>SkiaDisplayList</code>对象设置填充到<code>RenderNode</code>中；</li>
<li>最后将根<code>View</code>的缓存<code>DisplayListOp</code>设置到<code>RootRenderNode</code>中，完成构建。</li>
</ol>
<p>以上整个构建绘制命令树的过程可以用如下流程图表示：</p>
<p><img src="https://s2.loli.net/2023/09/08/HKJOz1F9eM25vnX.webp" alt="img"></p>
<p>硬件加速下的整个界面的View树的结构如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/08/zEwruLJ1I6xXc7R.webp" alt="img"></p>
<p>最后从systrace上看这个过程如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/08/SPpcveWVK1YDCqJ.webp" alt="img"></p>
<h3 id="2-执行渲染绘制任务"><a href="#2-执行渲染绘制任务" class="headerlink" title="2 执行渲染绘制任务"></a>2 执行渲染绘制任务</h3><p>经过上一小节中的分析，应用在<code>UI</code>线程中从根节点<code>DecorView</code>出发，递归遍历每个子<code>View</code>节点，搜集其<code>drawXXX</code>绘制动作并转换成<code>DisplayListOp</code>命令，将其记录到<code>DisplayListData</code>并填充到<code>RenderNode</code>中，最终完成整个<code>View</code>绘制命令树的构建。从此UI线程的绘制任务就完成了。下一步<code>UI</code>线程将唤醒<code>RenderThread</code>渲染线程，触发其利用<code>OpenGL</code>执行界面的渲染任务，本小节中我们将重点分析这个流程。我们还是先看看这块代码的简化流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/graphics/java/android/graphics/HardwareRenderer.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">syncAndDrawFrame</span><span class="params">(<span class="meta">@NonNull</span> FrameInfo frameInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// JNI调用native层的相关函数</span></span><br><span class="line">    <span class="keyword">return</span> nSyncAndDrawFrame(mNativeProxy, frameInfo.frameInfo, frameInfo.frameInfo.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/libs/hwui/jni/android_graphics_HardwareRenderer.cpp*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="params">(JNIEnv* env, jobject clazz,</span></span><br><span class="line"><span class="params">        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    RenderProxy* proxy = reinterpret_cast&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    env-&gt;GetLongArrayRegion(frameInfo, <span class="number">0</span>, frameInfoSize, proxy-&gt;frameInfo());</span><br><span class="line">    <span class="keyword">return</span> proxy-&gt;syncAndDrawFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/libs/hwui/renderthread/RenderProxy.cpp*/</span></span><br><span class="line"><span class="type">int</span> RenderProxy::syncAndDrawFrame() &#123;</span><br><span class="line">    <span class="comment">// 唤醒RenderThread渲染线程，执行DrawFrame绘制任务</span></span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp*/</span></span><br><span class="line"><span class="type">int</span> DrawFrameTask::drawFrame() &#123;</span><br><span class="line">    ...</span><br><span class="line">    postAndWait();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DrawFrameTask::postAndWait() &#123;</span><br><span class="line">    AutoMutex <span class="title function_">_lock</span><span class="params">(mLock)</span>;</span><br><span class="line">    <span class="comment">// 向RenderThread渲染线程的MessageQueue消息队列放入一个待执行任务，以将其唤醒执行run函数</span></span><br><span class="line">    mRenderThread-&gt;queue().post([<span class="built_in">this</span>]() &#123; run(); &#125;);</span><br><span class="line">    <span class="comment">// UI线程暂时进入wait等待状态</span></span><br><span class="line">    mSignal.wait(mLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DrawFrameTask::run() &#123;</span><br><span class="line">    <span class="comment">// 原生标识一帧渲染绘制任务的systrace tag</span></span><br><span class="line">    ATRACE_NAME(<span class="string">&quot;DrawFrame&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        TreeInfo <span class="title function_">info</span><span class="params">(TreeInfo::MODE_FULL, *mContext)</span>;</span><br><span class="line">        <span class="comment">//1.将UI线程构建的DisplayListOp绘制命令树同步到RenderThread渲染线程</span></span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 同步完成后则可以唤醒UI线程</span></span><br><span class="line">    <span class="keyword">if</span> (canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        <span class="comment">// 2.执行draw渲染绘制动作</span></span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool DrawFrameTask::syncFrameState(TreeInfo&amp; info) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 调用CanvasContext的prepareTree函数实现绘制命令树同步的流程</span></span><br><span class="line">    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/libs/hwui/renderthread/CanvasContext.cpp*/</span></span><br><span class="line"><span class="keyword">void</span> CanvasContext::prepareTree(TreeInfo&amp; info, int64_t* uiFrameInfo, int64_t syncQueued,</span><br><span class="line">                                RenderNode* target) &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">for</span> (const sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 递归调用各个子View对应的RenderNode执行prepareTree动作</span></span><br><span class="line">        node-&gt;prepareTree(info);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/libs/hwui/RenderNode.cpp*/</span></span><br><span class="line"><span class="keyword">void</span> RenderNode::prepareTree(TreeInfo&amp; info) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ...</span><br><span class="line">    prepareTreeImpl(observer, info, <span class="literal">false</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderNode::prepareTreeImpl(TreeObserver&amp; observer, TreeInfo&amp; info, bool functorsNeedLayer) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (info.mode == TreeInfo::MODE_FULL) &#123;</span><br><span class="line">        <span class="comment">// 同步绘制命令树</span></span><br><span class="line">        pushStagingDisplayListChanges(observer, info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDisplayList) &#123;</span><br><span class="line">        <span class="comment">// 遍历调用各个子View对应的RenderNode的prepareTreeImpl</span></span><br><span class="line">        <span class="type">bool</span> <span class="variable">isDirty</span> <span class="operator">=</span> mDisplayList-&gt;prepareListAndChildren(</span><br><span class="line">                observer, info, childFunctorsNeedLayer,</span><br><span class="line">                [](RenderNode* child, TreeObserver&amp; observer, TreeInfo&amp; info,</span><br><span class="line">                   bool functorsNeedLayer) &#123;</span><br><span class="line">                    child-&gt;prepareTreeImpl(observer, info, functorsNeedLayer);</span><br><span class="line">                &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderNode::pushStagingDisplayListChanges(TreeObserver&amp; observer, TreeInfo&amp; info) &#123;</span><br><span class="line">    ...</span><br><span class="line">    syncDisplayList(observer, &amp;info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderNode::syncDisplayList(TreeObserver&amp; observer, TreeInfo* info) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 完成赋值同步DisplayList对象</span></span><br><span class="line">    mDisplayList = mStagingDisplayList;</span><br><span class="line">    mStagingDisplayList = nullptr;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CanvasContext::draw() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.调用OpenGL库使用GPU，按照构建好的绘制命令完成界面的渲染</span></span><br><span class="line">    <span class="type">bool</span> <span class="variable">drew</span> <span class="operator">=</span> mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,</span><br><span class="line">                                      mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes,</span><br><span class="line">                                      &amp;(profiler()));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2.将前面已经绘制渲染好的图形缓冲区Binder上帧给SurfaceFlinger合成和显示</span></span><br><span class="line">    <span class="type">bool</span> <span class="variable">didSwap</span> <span class="operator">=</span></span><br><span class="line">            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出：<code>UI</code>线程利用<code>RenderProxy</code>向<code>RenderThread</code>线程发送一个<code>DrawFrameTask</code>任务请求，**<code>RenderThread</code>被唤醒，开始渲染，大致流程如下**：</p>
<ol>
<li><code>syncFrameState</code>中遍历<code>View</code>树上每一个<code>RenderNode</code>，执行<code>prepareTreeImpl</code>函数，实现同步绘制命令树的操作；</li>
<li>调用<code>OpenGL</code>库<code>API</code>使用<code>GPU</code>，按照构建好的绘制命令完成界面的渲染（具体过程，由于本文篇幅所限，暂不展开分析）；</li>
<li>将前面已经绘制渲染好的图形缓冲区<code>Binder</code>上帧给<code>SurfaceFlinger</code>合成和显示；</li>
</ol>
<p>整个过程可以用如下流程图表示：</p>
<p><img src="https://s2.loli.net/2023/09/08/3wcSklGu5XQR9Nz.webp" alt="img"></p>
<p>从systrace上这个过程如下图所示：</p>
<p><img src="https://s2.loli.net/2023/09/08/wqmLNgtAnRIeHib.webp" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://ljm2007.github.io">清风醉博客</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://ljm2007.github.io/2023/09/07/HeiBaoBox%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(2)----%E5%90%AF%E5%8A%A8APK/">http://ljm2007.github.io/2023/09/07/HeiBaoBox%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(2)----%E5%90%AF%E5%8A%A8APK/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ljm2007.github.io" target="_blank">清风醉博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/HeiBaoBox/">HeiBaoBox</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/09/07/Q3kjRwDr8dlMZbC.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/07/HeiBaoBox%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(3)----%E5%90%AF%E5%8A%A8APK/"><img class="prev-cover" src="https://s2.loli.net/2023/09/07/Q3kjRwDr8dlMZbC.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HeiBaoBox源码分析(3)----启动APK</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/04/BlackReflection/"><img class="next-cover" src="https://s2.loli.net/2023/09/09/qIJnlMTRFeWhciy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BlackReflection</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/04/BlackReflection/" title="BlackReflection"><img class="cover" src="https://s2.loli.net/2023/09/09/qIJnlMTRFeWhciy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-04</div><div class="title">BlackReflection</div></div></a></div><div><a href="/2023/09/02/HeiBaoBox%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)----%E8%A3%85%E8%BD%BDAPK/" title="HeiBaoBox源码分析(1)----装载APK"><img class="cover" src="https://s2.loli.net/2023/09/02/JmQp1xFdUXbIZvH.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-02</div><div class="title">HeiBaoBox源码分析(1)----装载APK</div></div></a></div><div><a href="/2023/09/07/HeiBaoBox%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(3)----%E5%90%AF%E5%8A%A8APK/" title="HeiBaoBox源码分析(3)----启动APK"><img class="cover" src="https://s2.loli.net/2023/09/07/Q3kjRwDr8dlMZbC.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-07</div><div class="title">HeiBaoBox源码分析(3)----启动APK</div></div></a></div><div><a href="/2023/09/08/%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82%E7%9A%84startActivity%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="浅显易懂的startActivity原理分析"><img class="cover" src="https://s2.loli.net/2023/09/09/qIJnlMTRFeWhciy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-08</div><div class="title">浅显易懂的startActivity原理分析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">清风醉博客</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ljm2007" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">一.创建应用进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AMS-%E5%8F%91%E9%80%81socket%E8%AF%B7%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">1.AMS 发送socket请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Zygote-%E5%A4%84%E7%90%86socket%E8%AF%B7%E6%B1%82"><span class="toc-number">1.2.</span> <span class="toc-text">2 Zygote 处理socket请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">3 应用进程初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BA%94%E7%94%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.4.</span> <span class="toc-text">4. 应用主线程消息循环机制建立</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%BA%94%E7%94%A8Application%E5%92%8CActivity%E7%BB%84%E4%BB%B6%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">二.应用Application和Activity组件创建与初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Application%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">1 Application的创建与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BA%94%E7%94%A8APK%E7%9A%84Dex%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.2.</span> <span class="toc-text">2.应用APK的Dex文件加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8APK%E7%9A%84Resource%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.3.</span> <span class="toc-text">3 应用APK的Resource资源加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-Activity%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">三.Activity的创建与初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Activity-Create"><span class="toc-number">3.1.</span> <span class="toc-text">1 Activity Create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Activity-Resume"><span class="toc-number">3.2.</span> <span class="toc-text">2 Activity Resume</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%BA%94%E7%94%A8UI%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BB%98%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">四. 应用UI布局与绘制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-RenderThread%E6%B8%B2%E6%9F%93"><span class="toc-number">5.</span> <span class="toc-text">五. RenderThread渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E5%BB%BA%E7%BB%98%E5%88%B6%E5%91%BD%E4%BB%A4%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">1 构建绘制命令树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E6%B8%B2%E6%9F%93%E7%BB%98%E5%88%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.2.</span> <span class="toc-text">2 执行渲染绘制任务</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/24/Compose%20Desktop%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8C%E4%BB%8E%E9%9B%B6%E5%88%B0%E6%89%93%E5%8C%85%EF%BC%8C%E4%B8%80%E7%9C%8B%E5%B0%B1%E4%BC%9A~/" title="Compose Desktop小白入门教程从零到打包"><img src="https://s2.loli.net/2024/02/26/yrfz2hPsEZKI9l3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Compose Desktop小白入门教程从零到打包"/></a><div class="content"><a class="title" href="/2024/02/24/Compose%20Desktop%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8C%E4%BB%8E%E9%9B%B6%E5%88%B0%E6%89%93%E5%8C%85%EF%BC%8C%E4%B8%80%E7%9C%8B%E5%B0%B1%E4%BC%9A~/" title="Compose Desktop小白入门教程从零到打包">Compose Desktop小白入门教程从零到打包</a><time datetime="2024-02-24T04:21:33.615Z" title="发表于 2024-02-24 12:21:33">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/18/Kotlin%20-by%20%E8%AF%A6%E8%A7%A3/" title="Kotlin 中 by 关键字"><img src="https://s2.loli.net/2023/05/20/nCWOkMglcT86x7p.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin 中 by 关键字"/></a><div class="content"><a class="title" href="/2024/02/18/Kotlin%20-by%20%E8%AF%A6%E8%A7%A3/" title="Kotlin 中 by 关键字">Kotlin 中 by 关键字</a><time datetime="2024-02-18T15:43:06.000Z" title="发表于 2024-02-18 23:43:06">2024-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/17/Handler%E6%9C%BA%E5%88%B6/" title="Android Handler：图文解析 Handler通信机制 的工作原理"><img src="https://s2.loli.net/2024/02/24/qYeL3VQMEbXmwJd.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android Handler：图文解析 Handler通信机制 的工作原理"/></a><div class="content"><a class="title" href="/2024/02/17/Handler%E6%9C%BA%E5%88%B6/" title="Android Handler：图文解析 Handler通信机制 的工作原理">Android Handler：图文解析 Handler通信机制 的工作原理</a><time datetime="2024-02-17T02:18:40.000Z" title="发表于 2024-02-17 10:18:40">2024-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/16/%E5%9C%A8Activity%E4%B8%AD%E4%BD%BF%E7%94%A8ViewBinding/" title="在Activity中使用ViewBinding"><img src="https://s2.loli.net/2023/09/02/zEhOgs8dyqo6ZjM.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在Activity中使用ViewBinding"/></a><div class="content"><a class="title" href="/2024/02/16/%E5%9C%A8Activity%E4%B8%AD%E4%BD%BF%E7%94%A8ViewBinding/" title="在Activity中使用ViewBinding">在Activity中使用ViewBinding</a><time datetime="2024-02-16T06:04:43.000Z" title="发表于 2024-02-16 14:04:43">2024-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/16/Kotlin%20%E4%B9%8B%20let%E3%80%81with%E3%80%81run%E3%80%81apply%E3%80%81also%20%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Kotlin 之 let、with、run、apply、also 函数的使用"><img src="https://s2.loli.net/2023/08/18/qGUY8y2d4CQXnxS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin 之 let、with、run、apply、also 函数的使用"/></a><div class="content"><a class="title" href="/2024/02/16/Kotlin%20%E4%B9%8B%20let%E3%80%81with%E3%80%81run%E3%80%81apply%E3%80%81also%20%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Kotlin 之 let、with、run、apply、also 函数的使用">Kotlin 之 let、with、run、apply、also 函数的使用</a><time datetime="2024-02-16T02:18:40.000Z" title="发表于 2024-02-16 10:18:40">2024-02-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 清风醉博客</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>